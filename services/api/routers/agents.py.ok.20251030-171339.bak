# services/api/routers/agents.py
from __future__ import annotations

import io
import os
import json
import time
from typing import Any, Dict

import numpy as np
import pandas as pd
from fastapi import APIRouter, UploadFile, File, Request, HTTPException

router = APIRouter(tags=["agents"])

RUNS_ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", ".runs"))
os.makedirs(RUNS_ROOT, exist_ok=True)

# ─────────────────────────────────────────────
# Helpers
# ─────────────────────────────────────────────
def _parse_form_to_params(form: Dict[str, Any]) -> Dict[str, Any]:
    """
    Convert starlette FormData into plain dict of strings -> values.
    Excludes UploadFile objects.
    """
    params: Dict[str, Any] = {}
    for k, v in form.items():
        if isinstance(v, UploadFile) or k == "file":
            continue
        if isinstance(v, (list, tuple)):
            params[k] = ",".join(map(str, v))
        else:
            params[k] = str(v)
    return params


def _load_csv_from_upload(upload: UploadFile | None) -> pd.DataFrame:
    if upload is None:
        raise HTTPException(status_code=400, detail="CSV file is required (multipart/form-data with 'file').")
    try:
        content = upload.file.read()
        return pd.read_csv(io.BytesIO(content))
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Could not parse CSV: {e}") from e


def _ensure_run_dir(run_id: str) -> str:
    run_dir = os.path.join(RUNS_ROOT, run_id)
    os.makedirs(run_dir, exist_ok=True)
    return run_dir


def _persist_minimal_artifacts(run_id: str, result: Dict[str, Any]) -> None:
    """
    Create minimal artifacts if the agent didn't persist any:
      - summary.json : contains the agent result minus large frames
      - merged.csv   : if provided as DataFrame or CSV content in result
    This won't overwrite files already present (so it's safe even if the agent wrote them).
    """
    run_dir = _ensure_run_dir(run_id)

    # Try to persist merged.csv if agent returned it explicitly
    merged_path = os.path.join(run_dir, "merged.csv")
    if not os.path.exists(merged_path):
        merged_df = None
        if isinstance(result, dict):
            # common keys where agent may put a DataFrame or CSV text
            for key in ("merged_df", "merged", "results_df"):
                if isinstance(result.get(key), pd.DataFrame):
                    merged_df = result.get(key)
                    break
            if merged_df is None:
                for key in ("merged_csv", "results_csv"):
                    csv_text = result.get(key)
                    if isinstance(csv_text, str) and csv_text.strip():
                        try:
                            df = pd.read_csv(io.StringIO(csv_text))
                            df.to_csv(merged_path, index=False)
                            merged_df = None  # already written
                            break
                        except Exception:
                            pass
        if isinstance(merged_df, pd.DataFrame):
            try:
                merged_df.to_csv(merged_path, index=False)
            except Exception:
                pass

    # Persist a small, JSON-safe summary (avoid DataFrames)
    summary_path = os.path.join(run_dir, "summary.json")
    if not os.path.exists(summary_path):
        try:
            with open(summary_path, "w", encoding="utf-8") as f:
                json.dump(_json_safe(result), f, ensure_ascii=False, indent=2)
        except Exception:
            pass


def _json_safe(obj: Any, max_str: int = 10_000) -> Any:
    """
    Make objects JSON serializable:
      - pandas.DataFrame -> schema summary only
      - numpy scalars -> Python scalars
      - bytes -> limited str
      - generic -> repr limited
    """
    if isinstance(obj, pd.DataFrame):
        return {"type": "dataframe", "shape": list(obj.shape), "columns": list(map(str, obj.columns))}
    if isinstance(obj, pd.Series):
        return {"type": "series", "length": int(obj.shape[0]), "name": str(obj.name)}

    if isinstance(obj, (np.integer,)):
        return int(obj)
    if isinstance(obj, (np.floating,)):
        return float(obj)
    if isinstance(obj, (np.bool_,)):
        return bool(obj)

    if isinstance(obj, dict):
        return {str(k): _json_safe(v, max_str=max_str) for k, v in obj.items()}
    if isinstance(obj, (list, tuple)):
        return [_json_safe(v, max_str=max_str) for v in obj]

    if isinstance(obj, (bytes, bytearray)):
        s = obj.decode("utf-8", errors="replace")
        return s if len(s) <= max_str else s[:max_str] + "…"
    if isinstance(obj, str):
        return obj if len(obj) <= max_str else obj[:max_str] + "…"

    if isinstance(obj, (int, float, bool)) or obj is None:
        return obj

    rep = repr(obj)
    return rep if len(rep) <= max_str else rep[:max_str] + "…"


# ─────────────────────────────────────────────
# Route
# ─────────────────────────────────────────────
@router.post("/v1/agents/{agent_name}/run")
async def run_agent(agent_name: str, request: Request, file: UploadFile | None = File(None)) -> Dict[str, Any]:
    allowed = {"credit_appraisal", "asset_appraisal", "asset"}
    if agent_name not in allowed:
        raise HTTPException(status_code=404, detail=f"Unknown agent '{agent_name}'")

    # Read form data (for fields) and take the CSV from `file`
    try:
        form = await request.form()
    except Exception:
        form = {}
    params = _parse_form_to_params(form)
    df = _load_csv_from_upload(file)

    # ---------- Branch: Asset Appraisal ----------
    if agent_name in {"asset_appraisal", "asset"}:
        # Prefer a proper module if present; otherwise fall back to a built-in heuristic.
        try:
            from agents.asset_appraisal import agent as asset_agent  # noqa: F401
            if hasattr(asset_agent, "run") and callable(asset_agent.run):
                raw_result = asset_agent.run(df, params)
            else:
                raise AttributeError("agents.asset_appraisal.agent.run(df, params) not found")
        except Exception:
            # Fallback: simple heuristic (keeps UI working even before model is trained)
            try:
                if "collateral_value" in df.columns:
                    base = df["collateral_value"].astype(float)
                else:
                    rng = np.random.default_rng(0)
                    base = pd.Series(rng.integers(20_000, 200_000, len(df)), index=df.index)

                bump_series = pd.Series(1.0, index=df.index, dtype="float64")
                for cand in ("collateral_type", "asset_type"):
                    if cand in df.columns:
                        bump_map = {
                            "real_estate": 1.12, "land": 1.08, "car": 0.95, "deposit": 1.00,
                            "Apartment": 1.10, "House": 1.12, "Condo": 1.08, "Shop": 1.15, "Factory": 1.20,
                            "Land Plot": 1.08, "Car": 0.95, "Deposit": 1.00
                        }
                        bump_series = df[cand].map(bump_map).fillna(1.0).astype(float)
                        break

                est = (base * bump_series).round(2)
                df_out = df.copy()
                df_out["estimated_collateral_value"] = est
                df_out["valuation_method"] = "heuristics"

                summary = {
                    "agent": "asset_appraisal",
                    "rows": int(len(df_out)),
                    "stats": {
                        "min": float(df_out["estimated_collateral_value"].min()),
                        "mean": float(df_out["estimated_collateral_value"].mean()),
                        "max": float(df_out["estimated_collateral_value"].max()),
                    },
                }
                raw_result = {
                    "run_id": f"asset_{int(time.time())}",
                    "summary": summary,
                }
            except Exception as e:
                raise HTTPException(status_code=500, detail=f"Asset appraisal failed: {e}") from e

        run_id = raw_result.get("run_id") or f"run_{int(time.time())}"
        try:
            _persist_minimal_artifacts(run_id, raw_result)
        except Exception:
            pass
        safe_result = _json_safe(raw_result)
        return {"run_id": run_id, "result": safe_result, "summary": safe_result.get("summary")}

    # ---------- Branch: Credit Appraisal ----------
    try:
        from agents.credit_appraisal import agent as credit_agent
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to import credit agent: {e}") from e

    fallback_run_id = f"run_{int(time.time())}"
    try:
        if hasattr(credit_agent, "run") and callable(credit_agent.run):
            raw_result = credit_agent.run(df, params)
        elif hasattr(credit_agent, "run_credit_appraisal") and callable(credit_agent.run_credit_appraisal):
            raw_result = credit_agent.run_credit_appraisal(df, **params)
        else:
            raise AttributeError("Credit agent entry missing. Provide `run(df, params)` or `run_credit_appraisal(df, **kwargs)`.")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Agent execution failed: {e}") from e

    run_id = (raw_result or {}).get("run_id") or fallback_run_id
    try:
        _persist_minimal_artifacts(run_id, raw_result or {})
    except Exception:
        pass

    safe_result = _json_safe(raw_result or {})
    return {"run_id": run_id, "result": safe_result, "summary": safe_result.get("summary")}
